# -*- coding: utf-8 -*-
"""Complete ECG Preprocessing .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OeKeDx-JpEjokXZs5Lvg6D94JCbTgIiN
"""

pip install neurokit2

import neurokit2 as nk
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.ndimage import minimum_filter1d, maximum_filter1d
import math
from scipy.ndimage import minimum_filter1d, maximum_filter1d

df = pd.DataFrame(pd.read_excel("ki.xls"))
l = df.columns.to_list()
df_new = df.copy()

plt.figure(figsize=(10, 3 * len(l)))
for idx, col in enumerate(l):
    plt.subplot(len(l), 1, idx + 1)
    plt.plot(df[col], label=col)
    plt.title(f"Signal: {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.legend(loc='upper right')

plt.tight_layout()
plt.show()

def erosion(signal, size):

    return minimum_filter1d(signal, size=size)

def dilation(signal, size):

    return maximum_filter1d(signal, size=size)

def opening(signal, size):

    eroded = erosion(signal, size)
    return dilation(eroded, size)

def closing(signal, size):

    dilated = dilation(signal, size)
    return erosion(dilated, size)

def oc_co(signal, size):

    opened_closed = closing(opening(signal, size), size)
    closed_opened = opening(closing(signal, size), size)
    return (opened_closed + closed_opened) / 2

def baseline_correction(ecg_signal, fs):

    k1_width = int(0.11 * fs)
    fb = oc_co(ecg_signal, k1_width)
    k2_width = int(0.27 * fs)
    fc = oc_co(fb, k2_width)

    fbc = ecg_signal[:len(fc)] - fc

    return fbc


fs = 360

for col in l:
    ecgsignal = df[col].dropna().to_numpy()
    corrected_ecg_b = baseline_correction(ecgsignal, fs)
    corrected_ecg = nk.signal_filter(corrected_ecg_b, sampling_rate=360 , method = "powerline" , powerline = 50)
    df_new[col] = pd.DataFrame({col : corrected_ecg})

plt.figure(figsize=(10, 3 * len(l)))
for idx, col in enumerate(l):
    plt.subplot(len(l), 1, idx + 1)
    plt.plot(df_new[col], label=col)
    plt.title(f"Signal: {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.legend(loc='upper right')

plt.tight_layout()
plt.show()

# outlier cleaning

def lwt(signal, col):
    data = signal[col] if isinstance(signal, pd.DataFrame) else signal
    window_size = 100

    min_values = []

    for i in range(len(data) - window_size + 1):
        window = data[i:i + window_size]
        min_values.append(window.min())

    result_df = pd.DataFrame({'min': min_values})
    rolling_var = result_df['min'].rolling(window=50).var()
    steady_state = rolling_var < 0.01

    steady_indices = np.where(steady_state)[0]
    if len(steady_indices) == 0:
        return result_df['min'].min()

    mn = result_df['min'].iloc[steady_indices[0]:steady_indices[-1]].min()
    return mn


def upt(signal, col):
    data = signal[col] if isinstance(signal, pd.DataFrame) else signal
    window_size = 100

    max_values = []

    for i in range(len(data) - window_size + 1):
        window = data[i:i + window_size]
        max_values.append(window.max())

    result_df = pd.DataFrame({'max': max_values})
    rolling_var = result_df['max'].rolling(window=50).var()
    steady_state = rolling_var < 0.01

    steady_indices = np.where(steady_state)[0]
    if len(steady_indices) == 0:
        return result_df['max'].max()

    maxx = result_df['max'].iloc[steady_indices[0]:steady_indices[-1]].max()
    return maxx


def out(signal):
    av = signal.mean()
    dev = signal.std()

    outlier_mask = (signal > av + dev) | (signal < av - dev)
    outlier_count = outlier_mask.sum()

    return outlier_count > 0.01 * len(signal)

def remove_outliers(signal, col=None):
    signal = pd.Series(signal) if not isinstance(signal, pd.Series) else signal

    if out(signal):

        lower_threshold = lwt(signal, col)
        upper_threshold = upt(signal, col)

        cleaned_signal = signal.copy()
        cleaned_signal[(signal > upper_threshold) | (signal < lower_threshold)] = np.nan

        cleaned_signal = cleaned_signal.interpolate(method='linear').fillna(method='bfill').fillna(method='ffill')
        return cleaned_signal
    else:
        return signal

df_new3 = df_new.copy()

for col in l:
    df_new3[col] = remove_outliers(df_new[col] , col)

plt.figure(figsize=(10, 3 * len(l)))

for idx, col in enumerate(l):
    plt.subplot(len(l), 1, idx + 1)
    plt.plot(df_new3[col], label=col ,  color='red')
    plt.title(f"Signal: {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.legend(loc='upper right')

plt.tight_layout()
plt.show()

df1 = pd.DataFrame(pd.read_excel("km.xls"))
l = df1.columns.to_list()
df_new1 = df1.copy()

plt.figure(figsize=(10, 3 * len(l)))
for idx, col in enumerate(l):
    plt.subplot(len(l), 1, idx + 1)
    plt.plot(df1[col], label=col)
    plt.title(f"Signal: {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.legend(loc='upper right')

plt.tight_layout()
# plt.savefig("raw_plot.png", dpi=300, bbox_inches='tight')
plt.show()

def erosion(signal, size):

    return minimum_filter1d(signal, size=size)

def dilation(signal, size):

    return maximum_filter1d(signal, size=size)

def opening(signal, size):

    eroded = erosion(signal, size)
    return dilation(eroded, size)

def closing(signal, size):

    dilated = dilation(signal, size)
    return erosion(dilated, size)

def oc_co(signal, size):

    opened_closed = closing(opening(signal, size), size)
    closed_opened = opening(closing(signal, size), size)
    return (opened_closed + closed_opened) / 2

def baseline_correction(ecg_signal, fs):

    k1_width = int(0.11 * fs)
    fb = oc_co(ecg_signal, k1_width)
    k2_width = int(0.27 * fs)
    fc = oc_co(fb, k2_width)

    fbc = ecg_signal[:len(fc)] - fc

    return fbc


fs = 360

for col in l:
    ecgsignal = df1[col].dropna().to_numpy()
    corrected_ecg_b = baseline_correction(ecgsignal, fs)
    corrected_ecg = nk.signal_filter(corrected_ecg_b, sampling_rate=360 , method = "powerline" , powerline = 50)
    df_new1[col] = pd.DataFrame({col : corrected_ecg})

def lwt(signal, col):
    data = signal[col] if isinstance(signal, pd.DataFrame) else signal
    window_size = 100

    min_values = []

    for i in range(len(data) - window_size + 1):
        window = data[i:i + window_size]
        min_values.append(window.min())

    result_df = pd.DataFrame({'min': min_values})
    rolling_var = result_df['min'].rolling(window=50).var()
    steady_state = rolling_var < 0.01

    steady_indices = np.where(steady_state)[0]
    if len(steady_indices) == 0:
        return result_df['min'].min()

    mn = result_df['min'].iloc[steady_indices[0]:steady_indices[-1]].min()
    return mn


def upt(signal, col):
    data = signal[col] if isinstance(signal, pd.DataFrame) else signal
    window_size = 100

    max_values = []

    for i in range(len(data) - window_size + 1):
        window = data[i:i + window_size]
        max_values.append(window.max())

    result_df = pd.DataFrame({'max': max_values})
    rolling_var = result_df['max'].rolling(window=50).var()
    steady_state = rolling_var < 0.01

    steady_indices = np.where(steady_state)[0]
    if len(steady_indices) == 0:
        return result_df['max'].max()

    maxx = result_df['max'].iloc[steady_indices[0]:steady_indices[-1]].max()
    return maxx


def out(signal):
    av = signal.mean()
    dev = signal.std()

    outlier_mask = (signal > av + dev) | (signal < av - dev)
    outlier_count = outlier_mask.sum()

    return outlier_count > 0.01 * len(signal)

def remove_outliers(signal, col=None):
    signal = pd.Series(signal) if not isinstance(signal, pd.Series) else signal

    if out(signal):

        lower_threshold = lwt(signal, col)
        upper_threshold = upt(signal, col)

        cleaned_signal = signal.copy()
        cleaned_signal[(signal > upper_threshold) | (signal < lower_threshold)] = np.nan

        cleaned_signal = cleaned_signal.interpolate(method='linear').fillna(method='bfill').fillna(method='ffill')
        return cleaned_signal
    else:
        return signal

df_new31 = df_new1.copy()

for col in l:
    df_new31[col] = remove_outliers(df_new1[col] , col)

plt.figure(figsize=(10, 3 * len(l)))

for idx, col in enumerate(l):
    plt.subplot(len(l), 1, idx + 1)
    plt.plot(df_new31[col], label=col ,  color='red')
    plt.title(f"Signal: {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")
    plt.grid(True)
    plt.legend(loc='upper right')

plt.tight_layout()
plt.savefig("cleaned_plot.png", dpi=300, bbox_inches='tight')
plt.show()

df_new3['I'] = (df_new3['I'] - df_new3['I'].mean()) / df_new3['I'].std()

l = df.columns.to_list()

import matplotlib.pyplot as plt
import pandas as pd
import neurokit2 as nk

# Iterate through each column in 'l'
for col in l:
    # Segment the signals for the current column
    q_epoch = nk.ecg_segment((df_new3[col] - df_new3[col].mean()) / df_new3[col].std(), rpeaks=None, sampling_rate=360, show=False)
    r_epoch = nk.ecg_segment((df_new31[col] - df_new31[col].mean()) / df_new31[col].std(), rpeaks=None, sampling_rate=360, show=False)

    # Initialize Series to accumulate signals for q_epoch
    zk = pd.Series([0] * len(q_epoch['1']['Signal']))
    for i in range(1, len(q_epoch)):
        zk += q_epoch[str(i)]['Signal'].reset_index(drop=True)
    zk = zk / len(q_epoch)  # Average the accumulated signals

    # Initialize Series to accumulate signals for r_epoch
    z = pd.Series([0] * len(r_epoch['1']['Signal']))
    for i in range(1, len(r_epoch)):
        z += r_epoch[str(i)]['Signal'].reset_index(drop=True)
    z = z / len(r_epoch)  # Average the accumulated signals

    # Create a new figure for the current column
    plt.figure(figsize=(8, 5))
    plt.title(f"Segmented Signals for {col}")
    plt.xlabel("Time (index)")
    plt.ylabel("Amplitude")

    # Plot the averaged signals
    zk.plot(linewidth=4, alpha=0.5, grid=True, color="red", label="Normal")
    z.plot(linewidth=4, alpha=0.5, grid=True, color="blue", label="LVDysfunction")

    # Add legend and display the plot
    plt.legend(loc="upper right")
    plt.tight_layout()

    plt.savefig(f"Avsignal{col}.png", dpi=300, bbox_inches='tight')
    plt.show()